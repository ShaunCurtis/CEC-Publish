<ul class="download">
	<li><a data-option="nofetch" href="https://github.com/ShaunCurtis/CEC-Publish/archive/master.zip">Download latest Repository Archive</a></li>
	<li><a href="https://github.com/ShaunCurtis/CEC-Publish/archive/master.zip">Download local copy</a></li>
</ul>

<h2>Part 3 - CRUD Operations in the UI</h2>

<h2>Introduction</h2>

<p>Part 2 describes techniques and methodologies for abstracting the data and business logic layers into boilerplate code in a library. This article does the same with the presentation layer.</p>

<h3>Sample Project and Code</h3>

<p>See the <a href="https://github.com/ShaunCurtis/CEC.Blazor">CEC.Blazor GitHub Repository</a> for the libraries and sample projects.</p>

<h3>The Base Forms</h3>

<p>The CRUD UI is implemented as a set of boilerplate components inheriting from <em>OwningComponentBase</em>. <em>OwningComponentBase</em> is used for control over the scope of Scoped Services. Code is available on the Github site and linked at appropriate places in this article.</p>

<h4>ApplicationComponentBase</h4>

<p><a href="https://github.com/ShaunCurtis/CEC.Blazor/blob/master/CEC.Blazor/Components/Base/ApplicationComponentBase.cs">CEC.Blazor/Components/Base.ApplicationComponentBase.cs</a></p>

<p><em>ApplicationComponentBase</em> is the base component and contains all the common client application code:</p>

<ol>
	<li>Injection of common services, such as Navigation Manager and Application Configuration.</li>
	<li>Authentication and user management.</li>
	<li>Navigation and Routing.</li>
</ol>

<h4>ControllerServiceComponent and Its Children</h4>

<p><a href="https://github.com/ShaunCurtis/CEC.Blazor/blob/master/CEC.Blazor/Components/Base/ControllerServiceComponentBase.cs">CEC.Blazor/Components/Base.ControllerServiceComponentBase.cs</a></p>

<p><a href="https://github.com/ShaunCurtis/CEC.Blazor/blob/master/CEC.Blazor/Components/Base/ControllerServiceComponentBase.cs"><em>ControllerServiceComponentBase</em></a> is the base CRUD component.</p>

<p>There are three inherited classes for specific CRUD operations:</p>

<ol>
	<li><a href="https://github.com/ShaunCurtis/CEC.Blazor/blob/master/CEC.Blazor/Components/Base/ListComponentBase.cs"><em>ListComponentBase</em></a> for all list pages</li>
	<li><em>RecordComponentBase</em> for displaying individual records.</li>
	<li><a href="https://github.com/ShaunCurtis/CEC.Blazor/blob/master/CEC.Blazor/Components/Base/EditComponentBase.cs"><em>EditComponentBase</em></a> for CUD [Create/Update/Delete] operations.</li>
</ol>

<p>All common code resides in <em>ControllerServiceComponent</em>, specific code in the inherited class.</p>

<h3>Implementing CRUD Pages</h3>

<p>We&#39;ll look at the editor in detail to see how the components are structured and edit functionality implemented.</p>

<h4>The View</h4>

<p>The routed view is a very simple component. We separate the actual view component from the routed view. It&#39;s used in other pages such as the modal dialog viewer.</p>

<pre lang="">
// CEC.Blazor.WASM.Client/Routes/WeatherForecastEditorView.razor
@page &quot;/WeatherForecast/New&quot;
@page &quot;/WeatherForecast/Edit&quot;
@inherits ApplicationComponentBase
@namespace CEC.Blazor.WASM.Client.Routes

&lt;WeatherEditorForm&gt;&lt;/WeatherEditorForm&gt;</pre>

<h4>The Form</h4>

<p>Again a relatively simple component programmatically.</p>

<pre lang="">
// CEC.Weather/Components/Forms/WeatherForecastEditorForm.razor
public partial class WeatherEditorForm : EditRecordComponentBase&lt;DbWeatherForecast, WeatherForecastDbContext&gt;
{
    [Inject]
    public WeatherForecastControllerService ControllerService { get; set; }

    private string CardCSS =&gt; this.IsModal ? &quot;m-0&quot; : &quot;&quot;;

    protected async override Task OnInitializedAsync()
    {
        // Assign the correct controller service
        this.Service = this.ControllerService;
        await base.OnInitializedAsync();
    }
}</pre>

<p>This gets and assigns the specific ControllerService through DI to the Service Property [IContollerService].</p>

<p>The Razor Markup below is an abbreviated version of the actual file. This makes extensive use of UIControls which will be discussed in detail in the next article. The comments provide explanation.</p>

<pre lang="">
// CEC.Weather/Components/Forms/WeatherForecastEditorForm.razor.cs
// UI Card is a Bootstrap Card
&lt;UICard IsCollapsible=&quot;false&quot;&gt;
    &lt;Header&gt;
        @this.PageTitle
    &lt;/Header&gt;
    &lt;Body&gt;
        // Cascades the Event Handler in the form for RecordChanged.  Picked up by each FormControl and fired when a value changes in the FormControl
        &lt;CascadingValue Value=&quot;@this.RecordFieldChanged&quot; Name=&quot;OnRecordChange&quot; TValue=&quot;Action&lt;bool&gt;&quot;&gt;
            // Error handler - only renders it&#39;s content when the record exists and is loaded
            &lt;UIErrorHandler IsError=&quot;@this.IsError&quot; IsLoading=&quot;this.IsDataLoading&quot; ErrorMessage=&quot;@this.RecordErrorMessage&quot;&gt;
                &lt;UIContainer&gt;
                    // Standard Blazor EditForm control
                    &lt;EditForm EditContext=&quot;this.EditContext&quot;&gt;
                        // Fluent ValidationValidator for the form
                        &lt;FluentValidationValidator DisableAssemblyScanning=&quot;@true&quot; /&gt;
                        .....
                        // Example data value row with label and edit control
                        &lt;UIFormRow&gt;
                            &lt;UILabelColumn Columns=&quot;4&quot;&gt;
                                Record Date:
                            &lt;/UILabelColumn&gt;
                            &lt;UIColumn Columns=&quot;4&quot;&gt;
                                // Note the Record Value bind to the record shadow copy to detect changes from the orginal stored value
                                &lt;FormControlDate class=&quot;form-control&quot; @bind-Value=&quot;this.Service.Record.Date&quot; RecordValue=&quot;this.Service.ShadowRecord.Date&quot;&gt;&lt;/FormControlDate&gt;
                            &lt;/UIColumn&gt;
                        &lt;/UIFormRow&gt;
                        ..... // more form rows here
                    &lt;/EditForm&gt;
                &lt;/UIContainer&gt;
            &lt;/UIErrorHandler&gt;
            // Container for the buttons - not record dependant so outside the error handler to allow navigation if UIErrorHandler is in error.
            &lt;UIContainer&gt;
                &lt;UIRow&gt;
                    &lt;UIColumn Columns=&quot;7&quot;&gt;
                        // Bootstrap alert to display any messages
                        &lt;UIAlert Alert=&quot;this.AlertMessage&quot; SizeCode=&quot;Bootstrap.SizeCode.sm&quot;&gt;&lt;/UIAlert&gt;
                    &lt;/UIColumn&gt;
                    &lt;UIButtonColumn Columns=&quot;5&quot;&gt;
                        ....
                        // UIButton is a Bootstrap button.  Show controls whether it&#39;s displayed.
                        // For example Save is displayed when the Service Record is Dirty and the record has loaded. 
                        &lt;UIButton Show=&quot;(!this.IsClean) &amp;&amp; this.IsLoaded&quot; ClickEvent=&quot;this.Save&quot; ColourCode=&quot;Bootstrap.ColourCode.save&quot;&gt;Save&lt;/UIButton&gt;
                        &lt;UIButton Show=&quot;this.ShowExitConfirmation &amp;&amp; this.IsLoaded&quot; ClickEvent=&quot;this.ConfirmExit&quot; ColourCode=&quot;Bootstrap.ColourCode.danger_exit&quot;&gt;Exit Without Saving&lt;/UIButton&gt;
                        &lt;UIButton Show=&quot;(!this.NavigationCancelled) &amp;&amp; !this.ShowExitConfirmation&quot; ClickEvent=&quot;(e =&gt; this.NavigateTo(PageExitType.ExitToList))&quot; ColourCode=&quot;Bootstrap.ColourCode.nav&quot;&gt;Exit To List&lt;/UIButton&gt;
                        &lt;UIButton Show=&quot;(!this.NavigationCancelled) &amp;&amp; !this.ShowExitConfirmation&quot; ClickEvent=&quot;this.Exit&quot; ColourCode=&quot;Bootstrap.ColourCode.nav&quot;&gt;Exit&lt;/UIButton&gt;
                    &lt;/UIButtonColumn&gt;
                &lt;/UIRow&gt;
            &lt;/UIContainer&gt;
        &lt;/CascadingValue&gt;
    &lt;/Body&gt;
&lt;/UICard&gt;</pre>

<h4>Base Form Code</h4>

<h5>OnInitializedAsync</h5>

<p>The code block below shows the two OnInitializedAsync methods in the class hierarchy.</p>

<p><em>OnInitializedAsync</em> is implemented from top down (local code is run before calling the base method).</p>

<pre lang="">
// CEC.Weather/Components/Forms/WeatherEditorForm.razor.cs
protected async override Task OnInitializedAsync()
{
    // Assign the correct controller service
    this.Service = this.ControllerService;
    // Set the delay on the record load as this is a demo project
    this.DemoLoadDelay = 250;
    await base.OnInitializedAsync();
}

// CEC.Blazor/Components/BaseForms/RecordComponentBase.cs
protected async override Task OnInitializedAsync()
{
    // Resets the record to blank 
    await this.Service.ResetRecordAsync();
    await base.OnInitializedAsync();
}

// CEC.Blazor/Components/BaseForms/ApplicationComponentBase.cs
protected async override Task OnInitializedAsync()
{
    // Gets the user if we have an AuthenticationState
    if (this.AuthenticationState != null) await this.GetUserAsync();
    await base.OnInitializedAsync();
}</pre>

<h5>OnParametersSetAsync</h5>

<p><em>OnParametersSetAsync</em> is implemented from bottom up (the base method is called before any local code).</p>

<pre lang="">
// CEC.Blazor/Components/BaseForms/ApplicationComponentBase.cs
protected async override Task OnParametersSetAsync()
{
    await base.OnParametersSetAsync();
    // Get the record if required - see below for method detail
    await this.LoadRecordAsync();
}</pre>

<h5>LoadRecordAsync</h5>

<p>The record loading code is broken out of <em>OnParametersSetAsync</em> as it&#39;s used outside the component lifecycle methods. It&#39;s implemented from bottom up (the base method is called before any local code).</p>

<pre lang="">
// CEC.Blazor/Components/BaseForms/RecordComponentBase.cs
protected virtual async Task LoadRecordAsync()
{
    if (this.IsService)
    {
        // Set the Loading flag and call StateNasChanged to force UI changes 
        // in this case making the UIErrorHandler show the loading spinner 
        this.IsDataLoading = true;
        StateHasChanged();

        // Check if we have a query string value in the Route for ID.  If so use it
        if (this.NavManager.TryGetQueryString&lt;int&gt;(&quot;id&quot;, out int querystringid)) this.ID = querystringid &gt; -1 ? querystringid : this._ID;

        // Check if the component is a modal.  If so get the supplied ID
        else if (this.IsModal &amp;&amp; this.Parent.Options.Parameters.TryGetValue(&quot;ID&quot;, out object modalid)) this.ID = (int)modalid &gt; -1 ? (int)modalid : this.ID;

        // make this look slow to demo the spinner
        if (this.DemoLoadDelay &gt; 0) await Task.Delay(this.DemoLoadDelay);

        // Get the current record - this will check if the id is different from the current record and only update if it&#39;s changed
        await this.Service.GetRecordAsync(this._ID, false);

        // Set the error message - it will only be displayed if we have an error
        this.RecordErrorMessage = $&quot;The Application can&#39;t load the Record with ID: {this._ID}&quot;;

        // Set the Loading flag and call statehaschanged to force UI changes 
        // in this case making the UIErrorHandler show the record or the error message 
        this.IsDataLoading = false;
        StateHasChanged();
    }
}

// CEC.Blazor/Components/BaseForms/EditComponentBase.cs
protected async override Task LoadRecordAsync()
{
    await base.LoadRecordAsync();

    //set up the Edit Context
    this.EditContext = new EditContext(this.Service.Record);

    // Get the actual page Url from the Navigation Manager
    this.RouteUrl = this.NavManager.Uri;
    // Set up this page as the active page in the router service
    this.RouterSessionService.ActiveComponent = this;
    // Wire up the router NavigationCancelled event
    this.RouterSessionService.NavigationCancelled += this.OnNavigationCancelled;
}</pre>

<h5>OnAfterRenderAsync</h5>

<p><em>OnAfterRenderAsync</em> is implemented from bottom up (base is called before any local code is executed).</p>

<pre lang="">
// CEC.Blazor/Components/BaseForms/RecordComponentBase.cs
protected async override Task OnAfterRenderAsync(bool firstRender)
{
    await base.OnAfterRenderAsync(firstRender);
    // Wire up the SameComponentNavigation Event - i.e. we potentially have a new record to load in the same View 
    if (firstRender) this.RouterSessionService.SameComponentNavigation += this.OnSameRouteRouting;
}</pre>

<h5>Event Handlers</h5>

<p>There are three event handlers wired up in the Component load events.</p>

<pre lang="">
// CEC.Blazor/Components/BaseForms/EditComponentBase.cs
// Event handler for a navigation cancelled event raised by the router
protected virtual void OnNavigationCancelled(object sender, EventArgs e)
{
    // Set the boolean properties
    this.NavigationCancelled = true;
    this.ShowExitConfirmation = true;
    // Set up the alert
    this.AlertMessage.SetAlert(&quot;&lt;b&gt;THIS RECORD ISN&#39;T SAVED&lt;/b&gt;. Either &lt;i&gt;Save&lt;/i&gt; or &lt;i&gt;Exit Without Saving&lt;/i&gt;.&quot;, Bootstrap.ColourCode.danger);
    // Trigger a component State update - buttons and alert need to be sorted
    InvokeAsync(this.StateHasChanged);
}</pre>

<pre lang="">
// CEC.Blazor/Components/BaseForms/EditComponentBase.cs
// Event handler for the RecordFromControls FieldChanged Event
protected virtual void RecordFieldChanged(bool isdirty)
{
    if (this.EditContext != null)
    {
        // Sort the Service Edit State
        this.Service.SetClean(!isdirty);
        // Set the boolean properties
        this.ShowExitConfirmation = false;
        this.NavigationCancelled = false;
        // Sort the component state based on the edit state
        if (this.IsClean)
        {
            this.AlertMessage.ClearAlert();
            this.RouterSessionService.SetPageExitCheck(false);
        }
        else
        {
            this.AlertMessage.SetAlert(&quot;The Record isn&#39;t Saved&quot;, Bootstrap.ColourCode.warning);
            this.RouterSessionService.SetPageExitCheck(true);
        }
        // Trigger a component State update - buttons and alert need to be sorted
        InvokeAsync(this.StateHasChanged);
    }
}</pre>

<pre lang="cs">
// CEC.Blazor/Components/BaseForms/RecordComponentBase.cs
// Event handler for SameRoute event raised by the router.  Check if we need to load a new record
protected async void OnSameRouteRouting(object sender, EventArgs e)
{
    // Gets the record - checks for a new ID in the querystring and if we have one loads the records
    await LoadRecordAsync();
}</pre>

<h5>Action Button Events</h5>

<p>There are four action events.</p>

<pre lang="cs">
// CEC.Blazor/Components/BaseForms/EditRecordComponentBase.cs
/// Save Method called from the Button
protected virtual async Task&lt;bool&gt; Save()
{
    var ok = false;
    // Validate the EditContext
    if (this.EditContext.Validate())
    {
        // Save the Record
        ok = await this.Service.SaveRecordAsync();
        if (ok)
        {
            // Set the EditContext State
            this.EditContext.MarkAsUnmodified();
            // Set the boolean properties
            this.ShowExitConfirmation = false;
            // Sort the Router session state
            this.RouterSessionService.NavigationCancelledUrl = string.Empty;
        }
        // Set the alert message to the return result
        this.AlertMessage.SetAlert(this.Service.TaskResult);
        // Trigger a component State update - buttons and alert need to be sorted
        this.UpdateState();
    }
    else this.AlertMessage.SetAlert(&quot;A validation error occurred.  Check individual fields for the relevant error.&quot;, Bootstrap.ColourCode.danger);
    return ok;
}</pre>

<pre lang="cs">
// CEC.Blazor/Components/BaseForms/EditRecordComponentBase.cs
/// Save and Exit Method called from the Button
protected virtual async void SaveAndExit()
{
    if (await this.Save()) this.ConfirmExit();
}</pre>

<pre lang="cs">
// CEC.Blazor/Components/BaseForms/EditRecordComponentBase.cs
/// Exit Method called from the Button
protected virtual void Exit()
{
    // Check if we are free (we have a clean record) to exit or need confirmation
    if (this.IsClean) ConfirmExit();
    else this.ShowExitConfirmation = true;
}</pre>

<pre lang="cs">
// CEC.Blazor/Components/BaseForms/EditRecordComponentBase.cs
/// Confirm Exit Method called from the Button
protected virtual void ConfirmExit()
{
    // To escape a dirty component set IsClean manually and navigate.
    this.Service.SetClean();
    // Sort the Router session state
    this.RouterSessionService.NavigationCancelledUrl = string.Empty;
    //turn off page exit checking
    this.RouterSessionService.SetPageExitCheck(false);
    // Sort the exit strategy
    if (this.IsModal) ModalExit();
    else
    {
        // Check if we have a Url the user tried to navigate to - default exit to the root
        if (!string.IsNullOrEmpty(this.RouterSessionService.NavigationCancelledUrl)) this.NavManager.NavigateTo(this.RouterSessionService.NavigationCancelledUrl);
        else if (!string.IsNullOrEmpty(this.RouterSessionService.ReturnRouteUrl)) this.NavManager.NavigateTo(this.RouterSessionService.ReturnRouteUrl);
        else this.NavManager.NavigateTo(&quot;/&quot;);
    }
}</pre>

<pre lang="cs">
// CEC.Blazor/Components/BaseForms/EditRecordComponentBase.cs
// Cancel Method called from the Button
protected void Cancel()
{
    // Set the boolean properties
    this.ShowExitConfirmation = false;
    this.NavigationCancelled = false;
    // Sort the Router session state
    this.RouterSessionService.NavigationCancelledUrl = string.Empty;
    // Sort the component state based on the edit state
    if (this.IsClean) this.AlertMessage.ClearAlert();
    else this.AlertMessage.SetAlert($&quot;{this.Service.RecordConfiguration.RecordDescription} Changed&quot;, Bootstrap.ColourCode.warning);
    // Trigger a component State update - buttons and alert need to be sorted
    this.UpdateState();
}</pre>

<h5>Navigation Buttons</h5>

<p>Various exit buttons are wired to and button handler call <em>NavigateTo</em>.</p>

<pre lang="cs">
// CEC.Blazor/Components/BaseForms/ControllerServiceComponentBase.cs
protected virtual void NavigateTo(PageExitType exittype)
{
    this.NavigateTo(new EditorEventArgs(exittype));
}

protected override void NavigateTo(EditorEventArgs e)
{
    if (IsService)
    {
        //check if record name is populated and if not populate it
        if (string.IsNullOrEmpty(e.RecordName)) e.RecordName = this.Service.RecordConfiguration.RecordName;

        // check if the id is set for view or edit.  If not, sets it.
        if ((e.ExitType == PageExitType.ExitToEditor || e.ExitType == PageExitType.ExitToView) &amp;&amp; e.ID == 0) e.ID = this._ID;
        base.NavigateTo(e);
    }
}</pre>

<p>These propagate down to <em>NavigateTo</em> in <em>ApplicationComponentBase</em></p>

<pre lang="cs">
// CEC.Blazor/Components/BaseForms/ApplicationComponentBase.cs
// Structured approach to organising record CRUD routing
protected virtual void NavigateTo(EditorEventArgs e)
{
    switch (e.ExitType)
    {
        case PageExitType.ExitToList:
            this.NavManager.NavigateTo($&quot;/{e.RecordName}/&quot;);
            break;
        case PageExitType.ExitToView:
            this.NavManager.NavigateTo($&quot;/{e.RecordName}/View?id={e.ID}&quot;);
            break;
        case PageExitType.ExitToEditor:
            this.NavManager.NavigateTo($&quot;/{e.RecordName}/Edit?id={e.ID}&quot;);
            break;
        case PageExitType.SwitchToEditor:
            this.NavManager.NavigateTo($&quot;/{e.RecordName}/Edit?id={e.ID}&quot;);
            break;
        case PageExitType.ExitToNew:
            this.NavManager.NavigateTo($&quot;/{e.RecordName}/New?qid={e.ID}&quot;);
            break;
        case PageExitType.ExitToLast:
            if (!string.IsNullOrEmpty(this.RouterSessionService.ReturnRouteUrl)) this.NavManager.NavigateTo(this.RouterSessionService.ReturnRouteUrl);
            this.NavManager.NavigateTo(&quot;/&quot;);
            break;
        case PageExitType.ExitToRoot:
            this.NavManager.NavigateTo(&quot;/&quot;);
            break;
        default:
            break;
    }
}</pre>

<h3>Wrap Up</h3>

<p>That wraps up this section. We&#39;ve looked at the Edit process in detail to see how the code works. The next section looks in detail at UI Controls seen in the razor markup in this article.</p>

<p>Some key points to note:</p>

<ol>
	<li>The differences in code between a Blazor Server and a Blazor WASM project are very minor.</li>
	<li>Most of the code resides in generic boilerplate classes.</li>
</ol>
