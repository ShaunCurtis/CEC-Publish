<ul class="download">
	<li><a data-option="nofetch" href="https://github.com/ShaunCurtis/CEC-Publish/archive/master.zip">Download latest Repository Archive</a></li>
	<li><a href="https://github.com/ShaunCurtis/CEC-Publish/archive/master.zip">Download local copy</a></li>
</ul>

<h2>Part 3 - CRUD Operations in the UI</h2>

<h2>Introduction</h2>

<p>This is the third in a set of articles looks at how to build and structure a real Database Application in Blazor. The five articles are:</p>

<ol>
	<li><a href="https://www.codeproject.com/Articles/5279560/Building-a-Database-Application-in-Blazor-Part-1-P">Project Structure and Framework</a></li>
	<li><a href="https://www.codeproject.com/Articles/5279596/Building-a-Database-Application-in-Blazor-Part-2-S">Services - Building the CRUD Data Layers</a></li>
	<li>View Components - Building the CRUD Presentation Layer</li>
	<li>UI Components - Building HTML/CSS Controls</li>
	<li>A walk through detailing how to add weather stations and weather station data to the application</li>
</ol>

<p>This article looks in detail at building reusable CRUD presentation layer components, and deploying them into both Server and WASM projects.</p>

<h3>Sample Project and Code</h3>

<p>See the <a href="https://github.com/ShaunCurtis/CEC.Blazor">CEC.Blazor GitHub Repository</a> for the libraries and sample projects.</p>

<h3>The Base Forms</h3>

<p>The CRUD UI components inherit from <code>OwningComponentBase</code>. We use <code>OwningComponentBase</code> in preference to <code>ComponentBase</code> because it gives control over the scope of Scoped Services. Not all code is shown - some class are too big to include in this article. All source files can be viewed on the Github site, and there are references or links to code files at appropriate places in the article.</p>

<h4>ApplicationComponentBase</h4>

<p><a href="https://github.com/ShaunCurtis/CEC.Blazor/blob/master/CEC.Blazor/Components/Base/ApplicationComponentBase.cs">CEC.Blazor/Components/Base.ApplicationComponentBase.cs</a></p>

<p><code>ApplicationComponentBase</code> is the base component and contains all the common client application code. It provides:</p>

<ol>
	<li>Injection of common services, such as Navigation Manager and Application Configuration.</li>
	<li>Authentication and user management.</li>
	<li>Navigation and Routing.</li>
	<li>A set of Common Properties that are used by th inheriting classes.</li>
</ol>

<h4>ControllerServiceComponent and Its Children</h4>

<p><a href="https://github.com/ShaunCurtis/CEC.Blazor/blob/master/CEC.Blazor/Components/Base/ControllerServiceComponentBase.cs"><code>ControllerServiceComponentBase</code></a> is the base CRUD component.</p>

<p>There are three inherited classes for specific CRUD operations:</p>

<ol>
	<li><a href="https://github.com/ShaunCurtis/CEC.Blazor/blob/master/CEC.Blazor/Components/Base/ListComponentBase.cs"><code>ListComponentBase</code></a> for all list pages</li>
	<li><code>RecordComponentBase</code> for displaying individual records.</li>
	<li><a href="https://github.com/ShaunCurtis/CEC.Blazor/blob/master/CEC.Blazor/Components/Base/EditComponentBase.cs"><code>EditComponentBase</code></a> for CUD [Create/Update/Delete] operations.</li>
</ol>

<p>All common code resides in <code>ControllerServiceComponent</code>, specific code in the inherited class.</p>

<p>These classes are relatively complex and long. We&#39;ll examine their functionality by looking at their deployment in the sample projects and then stepping back into the base components to see how their specific functionility is implemented.</p>

<h3>Implementing CRUD Pages</h3>

<p>We&#39;ll look at edit operations in detail to see how the components are structured and edit functionality implemented.</p>

<h4>The View</h4>

<p>The routed view is a very simple component. The actual code is implemented in a separate form component that is also used in the modal dialog editor.</p>

<pre lang="">
// CEC.Blazor.WASM.Client/Routes/WeatherForecastEditorView.razor
@page &quot;/WeatherForecast/New&quot;
@page &quot;/WeatherForecast/Edit&quot;
@inherits ApplicationComponentBase
@namespace CEC.Blazor.WASM.Client.Routes

&lt;WeatherEditorForm&gt;&lt;/WeatherEditorForm&gt;</pre>

<h4>The Form</h4>

<p>The code file is relatively simple, with most of the detail in the razor markup file.</p>

<pre lang="">
// CEC.Weather/Components/Forms/WeatherForecastEditorForm.razor
public partial class WeatherEditorForm : EditRecordComponentBase&lt;DbWeatherForecast, WeatherForecastDbContext&gt;
{
    [Inject]
    public WeatherForecastControllerService ControllerService { get; set; }

    private string CardCSS =&gt; this.IsModal ? &quot;m-0&quot; : &quot;&quot;;

    protected async override Task OnInitializedAsync()
    {
        // Assign the correct controller service
        this.Service = this.ControllerService;
        await base.OnInitializedAsync();
    }
}</pre>

<p>This gets and assigns the specific ControllerService through DI to the Service Property <code>IContollerService</code>.</p>

<p>The Razor Markup below is an abbreviated version of the actual file. This makes extensive use of UIControls which will be covered in detail in the next article. The comments provide explanation.</p>

<pre lang="">
// CEC.Weather/Components/Forms/WeatherForecastEditorForm.razor.cs
// UI Card is a Bootstrap Card
&lt;UICard IsCollapsible=&quot;false&quot;&gt;
    &lt;Header&gt;
        @this.PageTitle
    &lt;/Header&gt;
    &lt;Body&gt;
        // Cascades the Event Handler in the form for RecordChanged.  Picked up by each FormControl and fired when a value changes in the FormControl
        &lt;CascadingValue Value=&quot;@this.RecordFieldChanged&quot; Name=&quot;OnRecordChange&quot; TValue=&quot;Action&lt;bool&gt;&quot;&gt;
            // Error handler - only renders it&#39;s content when the record exists and is loaded
            &lt;UIErrorHandler IsError=&quot;@this.IsError&quot; IsLoading=&quot;this.IsDataLoading&quot; ErrorMessage=&quot;@this.RecordErrorMessage&quot;&gt;
                &lt;UIContainer&gt;
                    // Standard Blazor EditForm control
                    &lt;EditForm EditContext=&quot;this.EditContext&quot;&gt;
                        // Fluent ValidationValidator for the form
                        &lt;FluentValidationValidator DisableAssemblyScanning=&quot;@true&quot; /&gt;
                        .....
                        // Example data value row with label and edit control
                        &lt;UIFormRow&gt;
                            &lt;UILabelColumn Columns=&quot;4&quot;&gt;
                                Record Date:
                            &lt;/UILabelColumn&gt;
                            &lt;UIColumn Columns=&quot;4&quot;&gt;
                                // Note the Record Value bind to the record shadow copy to detect changes from the orginal stored value
                                &lt;FormControlDate class=&quot;form-control&quot; @bind-Value=&quot;this.Service.Record.Date&quot; RecordValue=&quot;this.Service.ShadowRecord.Date&quot;&gt;&lt;/FormControlDate&gt;
                            &lt;/UIColumn&gt;
                        &lt;/UIFormRow&gt;
                        ..... // more form rows here
                    &lt;/EditForm&gt;
                &lt;/UIContainer&gt;
            &lt;/UIErrorHandler&gt;
            // Container for the buttons - not record dependant so outside the error handler to allow navigation if UIErrorHandler is in error.
            &lt;UIContainer&gt;
                &lt;UIRow&gt;
                    &lt;UIColumn Columns=&quot;7&quot;&gt;
                        // Bootstrap alert to display any messages
                        &lt;UIAlert Alert=&quot;this.AlertMessage&quot; SizeCode=&quot;Bootstrap.SizeCode.sm&quot;&gt;&lt;/UIAlert&gt;
                    &lt;/UIColumn&gt;
                    &lt;UIButtonColumn Columns=&quot;5&quot;&gt;
                        ....
                        // UIButton is a Bootstrap button.  Show controls whether it&#39;s displayed.
                        // For example Save is displayed when the Service Record is Dirty and the record has loaded. 
                        &lt;UIButton Show=&quot;(!this.IsClean) &amp;&amp; this.IsLoaded&quot; ClickEvent=&quot;this.Save&quot; ColourCode=&quot;Bootstrap.ColourCode.save&quot;&gt;Save&lt;/UIButton&gt;
                        &lt;UIButton Show=&quot;this.ShowExitConfirmation &amp;&amp; this.IsLoaded&quot; ClickEvent=&quot;this.ConfirmExit&quot; ColourCode=&quot;Bootstrap.ColourCode.danger_exit&quot;&gt;Exit Without Saving&lt;/UIButton&gt;
                        &lt;UIButton Show=&quot;(!this.NavigationCancelled) &amp;&amp; !this.ShowExitConfirmation&quot; ClickEvent=&quot;(e =&gt; this.NavigateTo(PageExitType.ExitToList))&quot; ColourCode=&quot;Bootstrap.ColourCode.nav&quot;&gt;Exit To List&lt;/UIButton&gt;
                        &lt;UIButton Show=&quot;(!this.NavigationCancelled) &amp;&amp; !this.ShowExitConfirmation&quot; ClickEvent=&quot;this.Exit&quot; ColourCode=&quot;Bootstrap.ColourCode.nav&quot;&gt;Exit&lt;/UIButton&gt;
                    &lt;/UIButtonColumn&gt;
                &lt;/UIRow&gt;
            &lt;/UIContainer&gt;
        &lt;/CascadingValue&gt;
    &lt;/Body&gt;
&lt;/UICard&gt;</pre>

<h4>Base Form Code</h4>

<p>At this point we step down into code in the base forms. Each function/code block is annotated with the name of the source component. We look at code blocks in the class inheritance hierarchy in the order in which is is executed.</p>

<h5>OnInitializedAsync</h5>

<p>The code block below shows the two OnInitializedAsync methods.</p>

<p><code>OnInitializedAsync</code> is implemented from top down (local code is run before calling the base method).</p>

<pre lang="">
// CEC.Weather/Components/Forms/WeatherEditorForm.razor.cs
protected async override Task OnInitializedAsync()
{
    // Assign the correct controller service
    this.Service = this.ControllerService;
    // Set the delay on the record load as this is a demo project
    this.DemoLoadDelay = 250;
    await base.OnInitializedAsync();
}

// CEC.Blazor/Components/BaseForms/RecordComponentBase.cs
protected async override Task OnInitializedAsync()
{
    // Resets the record to blank 
    await this.Service.ResetRecordAsync();
    await base.OnInitializedAsync();
}

// CEC.Blazor/Components/BaseForms/ApplicationComponentBase.cs
protected async override Task OnInitializedAsync()
{
    // Gets the user if we have an AuthenticationState
    if (this.AuthenticationState != null) await this.GetUserAsync();
    await base.OnInitializedAsync();
}</pre>

<h5>OnParametersSetAsync</h5>

<p><code>OnParametersSetAsync</code> is implemented from bottom up (base method is called before any local code).</p>

<pre lang="">
// CEC.Blazor/Components/BaseForms/ApplicationComponentBase.cs
protected async override Task OnParametersSetAsync()
{
    await base.OnParametersSetAsync();
    // Get the record if required - see below for method detail
    await this.LoadRecordAsync();
}</pre>

<h5>LoadRecordAsync</h5>

<p>The record loading code is broken out as it&#39;s used outside the component lifecycle methods. It&#39;s implemented from bottom up (base method is called before any local code).</p>

<p>The primary record load functionaility is in <code>RecordComponentBase</code> which gets and loads the record based on ID. <code>EditComponentBase</code> adds the extra functionality for editing rather than just viewing the record.</p>

<pre lang="">
// CEC.Blazor/Components/BaseForms/RecordComponentBase.cs
protected virtual async Task LoadRecordAsync()
{
    if (this.IsService)
    {
        // Set the Loading flag and call StateNasChanged to force UI changes 
        // in this case making the UIErrorHandler show the loading spinner 
        this.IsDataLoading = true;
        StateHasChanged();

        // Check if we have a query string value in the Route for ID.  If so use it
        if (this.NavManager.TryGetQueryString&lt;int&gt;(&quot;id&quot;, out int querystringid)) this.ID = querystringid &gt; -1 ? querystringid : this._ID;

        // Check if the component is a modal.  If so get the supplied ID
        else if (this.IsModal &amp;&amp; this.Parent.Options.Parameters.TryGetValue(&quot;ID&quot;, out object modalid)) this.ID = (int)modalid &gt; -1 ? (int)modalid : this.ID;

        // make this look slow to demo the spinner
        if (this.DemoLoadDelay &gt; 0) await Task.Delay(this.DemoLoadDelay);

        // Get the current record - this will check if the id is different from the current record and only update if it&#39;s changed
        await this.Service.GetRecordAsync(this._ID, false);

        // Set the error message - it will only be displayed if we have an error
        this.RecordErrorMessage = $&quot;The Application can&#39;t load the Record with ID: {this._ID}&quot;;

        // Set the Loading flag and call statehaschanged to force UI changes 
        // in this case making the UIErrorHandler show the record or the error message 
        this.IsDataLoading = false;
        StateHasChanged();
    }
}

// CEC.Blazor/Components/BaseForms/EditComponentBase.cs
protected async override Task LoadRecordAsync()
{
    await base.LoadRecordAsync();

    //set up the Edit Context
    this.EditContext = new EditContext(this.Service.Record);

    // Get the actual page Url from the Navigation Manager
    this.RouteUrl = this.NavManager.Uri;
    // Set up this page as the active page in the router service
    this.RouterSessionService.ActiveComponent = this;
    // Wire up the router NavigationCancelled event
    this.RouterSessionService.NavigationCancelled += this.OnNavigationCancelled;
}</pre>

<h5>OnAfterRenderAsync</h5>

<p><code>OnAfterRenderAsync</code> is implemented from bottom up (base is called before any local code is executed).</p>

<pre lang="">
// CEC.Blazor/Components/BaseForms/RecordComponentBase.cs
protected async override Task OnAfterRenderAsync(bool firstRender)
{
    await base.OnAfterRenderAsync(firstRender);
    // Wire up the SameComponentNavigation Event - i.e. we potentially have a new record to load in the same View 
    if (firstRender) this.RouterSessionService.SameComponentNavigation += this.OnSameRouteRouting;
}</pre>

<h5>Event Handlers</h5>

<p>There are three event handlers wired up in the Component load events.</p>

<pre lang="">
// CEC.Blazor/Components/BaseForms/EditComponentBase.cs
// Event handler for a navigation cancelled event raised by the router
protected virtual void OnNavigationCancelled(object sender, EventArgs e)
{
    // Set the boolean properties
    this.NavigationCancelled = true;
    this.ShowExitConfirmation = true;
    // Set up the alert
    this.AlertMessage.SetAlert(&quot;&lt;b&gt;THIS RECORD ISN&#39;T SAVED&lt;/b&gt;. Either &lt;i&gt;Save&lt;/i&gt; or &lt;i&gt;Exit Without Saving&lt;/i&gt;.&quot;, Bootstrap.ColourCode.danger);
    // Trigger a component State update - buttons and alert need to be sorted
    InvokeAsync(this.StateHasChanged);
}</pre>

<pre lang="">
// CEC.Blazor/Components/BaseForms/EditComponentBase.cs
// Event handler for the Record Form Controls FieldChanged Event
// wired to each control through a cascaded parameter
protected virtual void RecordFieldChanged(bool isdirty)
{
    if (this.EditContext != null)
    {
        // Sort the Service Edit State
        this.Service.SetClean(!isdirty);
        // Set the boolean properties
        this.ShowExitConfirmation = false;
        this.NavigationCancelled = false;
        // Sort the component state based on the edit state
        if (this.IsClean)
        {
            this.AlertMessage.ClearAlert();
            this.RouterSessionService.SetPageExitCheck(false);
        }
        else
        {
            this.AlertMessage.SetAlert(&quot;The Record isn&#39;t Saved&quot;, Bootstrap.ColourCode.warning);
            this.RouterSessionService.SetPageExitCheck(true);
        }
        // Trigger a component State update - buttons and alert need to be sorted
        InvokeAsync(this.StateHasChanged);
    }
}</pre>

<pre lang="">
// CEC.Blazor/Components/BaseForms/RecordComponentBase.cs
// Event handler for SameRoute event raised by the router.  The ID Querystring may have changed and we need to load a new record
protected async void OnSameRouteRouting(object sender, EventArgs e)
{
    // Gets the record - checks for a new ID in the querystring and if we have one loads the new record
    await LoadRecordAsync();
}</pre>

<h5>Action Button Events</h5>

<p>There are four action events.</p>

<pre lang="">
// CEC.Blazor/Components/BaseForms/EditRecordComponentBase.cs
/// Save Method called from the Button
protected virtual async Task&lt;bool&gt; Save()
{
    var ok = false;
    // Validate the EditContext
    if (this.EditContext.Validate())
    {
        // Save the Record
        ok = await this.Service.SaveRecordAsync();
        if (ok)
        {
            // Reset the EditContext State to clean
            this.EditContext.MarkAsUnmodified();
            // Set the boolean properties
            this.ShowExitConfirmation = false;
            // Sort the Router session state to clean
            this.RouterSessionService.NavigationCancelledUrl = string.Empty;
        }
        // Set the alert message to the return result
        this.AlertMessage.SetAlert(this.Service.TaskResult);
        // Trigger a component State update - buttons and alert need to be sorted
        this.UpdateState();
    }
    else this.AlertMessage.SetAlert(&quot;A validation error occurred.  Check individual fields for the relevant error.&quot;, Bootstrap.ColourCode.danger);
    return ok;
}</pre>

<pre lang="">
// CEC.Blazor/Components/BaseForms/EditRecordComponentBase.cs
/// Save and Exit Method called from the Button
protected virtual async void SaveAndExit()
{
    if (await this.Save()) this.ConfirmExit();
}</pre>

<pre lang="">
// CEC.Blazor/Components/BaseForms/EditRecordComponentBase.cs
/// Exit Method called from the Button
protected virtual void Exit()
{
    // Check if we are free to exit (we have a clean record) or need confirmation
    if (this.IsClean) ConfirmExit();
    else this.ShowExitConfirmation = true;
}</pre>

<pre lang="">
// CEC.Blazor/Components/BaseForms/EditRecordComponentBase.cs
/// Confirm Exit Method called from the Button - bail out regardless
protected virtual void ConfirmExit()
{
    // Override the sate to clean - the router only lets us escape if the state is clean.
    this.Service.SetClean();
    // Sort the Router session state
    this.RouterSessionService.NavigationCancelledUrl = string.Empty;
    //turn off page exit checking
    this.RouterSessionService.SetPageExitCheck(false);
    // Sort the exit strategy - where does the user want to exit to.
    if (this.IsModal) ModalExit();
    else
    {
        // Check if we have a Url the user tried to navigate to - default exit to the root
        if (!string.IsNullOrEmpty(this.RouterSessionService.NavigationCancelledUrl)) this.NavManager.NavigateTo(this.RouterSessionService.NavigationCancelledUrl);
        else if (!string.IsNullOrEmpty(this.RouterSessionService.ReturnRouteUrl)) this.NavManager.NavigateTo(this.RouterSessionService.ReturnRouteUrl);
        else this.NavManager.NavigateTo(&quot;/&quot;);
    }
}</pre>

<pre lang="">
// CEC.Blazor/Components/BaseForms/EditRecordComponentBase.cs
// Cancel Method called from the Button
protected void Cancel()
{
    // Set the boolean properties
    this.ShowExitConfirmation = false;
    this.NavigationCancelled = false;
    // Sort the Router session state
    this.RouterSessionService.NavigationCancelledUrl = string.Empty;
    // Sort the component state based on the edit state
    if (this.IsClean) this.AlertMessage.ClearAlert();
    else this.AlertMessage.SetAlert($&quot;{this.Service.RecordConfiguration.RecordDescription} Changed&quot;, Bootstrap.ColourCode.warning);
    // Trigger a component State update - buttons and alert need to be sorted
    this.UpdateState();
}</pre>

<h5>Navigation Buttons</h5>

<p><code>NavigateTo</code> provides a structured approach to navigation between, and exiting from, forms. Exit buttons are wired directly to <code>NavigateTo</code> and buttons such as SaveAndExit call it.</p>

<pre lang="">
// CEC.Blazor/Components/BaseForms/ControllerServiceComponentBase.cs
protected virtual void NavigateTo(PageExitType exittype)
{
    this.NavigateTo(new EditorEventArgs(exittype));
}

protected override void NavigateTo(EditorEventArgs e)
{
    if (IsService)
    {
        //check if record name is populated and if not populate it
        if (string.IsNullOrEmpty(e.RecordName)) e.RecordName = this.Service.RecordConfiguration.RecordName;

        // check if the id is set for view or edit.  If not, sets it.
        if ((e.ExitType == PageExitType.ExitToEditor || e.ExitType == PageExitType.ExitToView) &amp;&amp; e.ID == 0) e.ID = this._ID;
        base.NavigateTo(e);
    }
}</pre>

<p>These propagate down to <code>NavigateTo</code> in <code>ApplicationComponentBase</code></p>

<pre lang="">
// CEC.Blazor/Components/BaseForms/ApplicationComponentBase.cs
protected virtual void NavigateTo(EditorEventArgs e)
{
    switch (e.ExitType)
    {
        case PageExitType.ExitToList:
            this.NavManager.NavigateTo($&quot;/{e.RecordName}/&quot;);
            break;
        case PageExitType.ExitToView:
            this.NavManager.NavigateTo($&quot;/{e.RecordName}/View?id={e.ID}&quot;);
            break;
        case PageExitType.ExitToEditor:
            this.NavManager.NavigateTo($&quot;/{e.RecordName}/Edit?id={e.ID}&quot;);
            break;
        case PageExitType.SwitchToEditor:
            this.NavManager.NavigateTo($&quot;/{e.RecordName}/Edit?id={e.ID}&quot;);
            break;
        case PageExitType.ExitToNew:
            this.NavManager.NavigateTo($&quot;/{e.RecordName}/New?qid={e.ID}&quot;);
            break;
        case PageExitType.ExitToLast:
            if (!string.IsNullOrEmpty(this.RouterSessionService.ReturnRouteUrl)) this.NavManager.NavigateTo(this.RouterSessionService.ReturnRouteUrl);
            this.NavManager.NavigateTo(&quot;/&quot;);
            break;
        case PageExitType.ExitToRoot:
            this.NavManager.NavigateTo(&quot;/&quot;);
            break;
        default:
            break;
    }
}</pre>

<h3>Wrap Up</h3>

<p>That wraps up this section. We&#39;ve looked at the Edit process in detail to see how the code works. The Viewer is simpler form of the editor. I&#39;ll look in more detail at the List components in a separate stand alone article. The next section looks in detail at UI Controls seen in the razor markup in this article.</p>

<p>Some key points to note:</p>

<ol>
	<li>The differences in code between a Blazor Server and a Blazor WASM project are very minor.</li>
	<li>Almost all the functionality needed is implemented in the library components. Most of the application code is Razor markup for the individual record fields.</li>
	<li>Extensive use of Async functionality iin the components and CRUD data access.</li>
</ol>
