<ul class="download">
	<li><a data-option="nofetch" href="https://github.com/ShaunCurtis/CEC-Publish/archive/master.zip">Download latest Repository Archive</a></li>
	<li><a href="https://github.com/ShaunCurtis/CEC-Publish/archive/master.zip">Download local copy</a></li>
</ul>

<h2>Part 4 - UI Components</h2>

<h2>Introduction</h2>

<p>This is the fourth article in the series looking at how to build and structure a real Database Application in Blazor. The articles so far are:</p>

<ol>
	<li><a href="https://www.codeproject.com/Articles/5279560/Building-a-Database-Application-in-Blazor-Part-1-P" rel="nofollow">Project Structure and Framework</a></li>
	<li><a href="https://www.codeproject.com/Articles/5279596/Building-a-Database-Application-in-Blazor-Part-2-S" rel="nofollow">Services - Building the CRUD Data Layers</a></li>
	<li><a href="https://www.codeproject.com/Articles/5279963/Building-a-Database-Application-in-Blazor-Part-3-C" rel="nofollow">View Components - CRUD Edit and View Operations in the UI</a></li>
	<li>UI Components - Building HTML/CSS Controls</li>
</ol>

<p>Further articles will look at</p>

<ul>
	<li>List Operations in the UI</li>
	<li>A walk through detailing how to add more records to the application - in this case weather stations and weather station data.</li>
</ul>

<p>This article looks at the components we use in the UI and then focuses on how to build generic UI Components from HTML and CSS.</p>

<h3>Sample Project and Code</h3>

<p>All the sample code and libraries are on GitHub - <a href="https://github.com/ShaunCurtis/CEC.Blazor">CEC.Blazor GitHub Repository</a>.</p>

<h3>Components</h3>

<p>For a detailed look at components read my article <a href="https://www.codeproject.com/Articles/5277618/A-Dive-into-Blazor-Components" rel="nofollow">A Dive into Blazor Components</a>.</p>

<p>I divide components into four categories:</p>

<ol>
	<li>Views - these are routed components/views.</li>
	<li>Forms - there can be one or more forms within a View, and one or more UIControls within a form. Edit/Display/List components are all forms.</li>
	<li>UIControls - these are collections of HTML markup and CSS. Similar to Form Controls.</li>
	<li>Layouts - these a special components used to layout a View.</li>
</ol>

<h3>Views</h3>

<p>Views are specific to the application and live in the <code>Routes</code> folder.</p>

<p>The Weather Forecast Viewer and List Views are shown below.</p>

<pre lang="c#">
// CEC.Blazor.Server/Routes/WeatherForecastViewerView.cs
@page &quot;/WeatherForecast/View&quot;

@namespace CEC.Blazor.Server.Pages

@inherits ApplicationComponentBase

&lt;WeatherViewer&gt;&lt;/WeatherViewer&gt;</pre>

<p>The list view defines a UIOptions object that control various list control display options.</p>

<pre lang="c#">
// CEC.Blazor.Server/Routes/WeatherForecastListView.cs
@page &quot;/WeatherForecast&quot;

@layout MainLayout

@namespace CEC.Blazor.Server.Routes

@inherits ApplicationComponentBase

&lt;WeatherList UIOptions=&quot;this.UIOptions&quot; &gt;&lt;/WeatherList&gt;

@code {
    public UIOptions UIOptions =&gt; new UIOptions()
    {
        ListNavigationToViewer = true,
        ShowButtons = true,
        ShowAdd = true,
        ShowEdit = true
    };
}</pre>

<h3>Forms</h3>

<p>Forms are also project specific, but are common to both WASM and Server deployments. In the Weather Application they reside in the CEC.Weather library.</p>

<p>The code below shows the Weather Viewer. It&#39;s all UI Controls, no HTML markup. The markup lives inside the controls - we&#39;ll look at some example UI Controls later.</p>

<pre lang="c#">
// CEC.Weather/Components/Forms/WeatherForecastViewerForm.razor
&lt;UICard&gt;
    &lt;Header&gt;
        @this.PageTitle
    &lt;/Header&gt;
    &lt;Body&gt;
        &lt;UIErrorHandler IsError=&quot;this.IsError&quot; IsLoading=&quot;this.IsDataLoading&quot; ErrorMessage=&quot;@this.RecordErrorMessage&quot;&gt;
            &lt;UIContainer&gt;
                &lt;UIRow&gt;
                    &lt;UILabelColumn Columns=&quot;2&quot;&gt;
                        Date
                    &lt;/UILabelColumn&gt;
                    &lt;UIColumn Columns=&quot;2&quot;&gt;
                        &lt;FormControlPlainText Value=&quot;@this.Service.Record.Date.AsShortDate()&quot;&gt;&lt;/FormControlPlainText&gt;
                    &lt;/UIColumn&gt;
                    &lt;UILabelColumn Columns=&quot;2&quot;&gt;
                        ID
                    &lt;/UILabelColumn&gt;
                    &lt;UIColumn Columns=&quot;2&quot;&gt;
                        &lt;FormControlPlainText Value=&quot;@this.Service.Record.ID.ToString()&quot;&gt;&lt;/FormControlPlainText&gt;
                    &lt;/UIColumn&gt;
                    &lt;UILabelColumn Columns=&quot;2&quot;&gt;
                        Frost
                    &lt;/UILabelColumn&gt;
                    &lt;UIColumn Columns=&quot;2&quot;&gt;
                        &lt;FormControlPlainText Value=&quot;@this.Service.Record.Frost.AsYesNo()&quot;&gt;&lt;/FormControlPlainText&gt;
                    &lt;/UIColumn&gt;
                &lt;/UIRow&gt;
            ..........
            &lt;/UIContainer&gt;
        &lt;/UIErrorHandler&gt;
        &lt;UIContainer&gt;
            &lt;UIRow&gt;
                &lt;UIColumn Columns=&quot;6&quot;&gt;
                    &lt;UIButton Show=&quot;this.IsLoaded&quot; ColourCode=&quot;Bootstrap.ColourCode.dark&quot; ClickEvent=&quot;(e =&gt; this.NextRecord(-1))&quot;&gt;
                        Previous
                    &lt;/UIButton&gt;
                    &lt;UIButton Show=&quot;this.IsLoaded&quot; ColourCode=&quot;Bootstrap.ColourCode.dark&quot; ClickEvent=&quot;(e =&gt; this.NextRecord(1))&quot;&gt;
                        Next
                    &lt;/UIButton&gt;
                &lt;/UIColumn&gt;
                &lt;UIButtonColumn Columns=&quot;6&quot;&gt;
                    &lt;UIButton Show=&quot;!this.IsModal&quot; ColourCode=&quot;Bootstrap.ColourCode.nav&quot; ClickEvent=&quot;(e =&gt; this.NavigateTo(PageExitType.ExitToList))&quot;&gt;
                        Exit To List
                    &lt;/UIButton&gt;
                    &lt;UIButton Show=&quot;!this.IsModal&quot; ColourCode=&quot;Bootstrap.ColourCode.nav&quot; ClickEvent=&quot;(e =&gt; this.NavigateTo(PageExitType.ExitToLast))&quot;&gt;
                        Exit
                    &lt;/UIButton&gt;
                    &lt;UIButton Show=&quot;this.IsModal&quot; ColourCode=&quot;Bootstrap.ColourCode.nav&quot; ClickEvent=&quot;(e =&gt; this.ModalExit())&quot;&gt;
                        Exit
                    &lt;/UIButton&gt;
                &lt;/UIButtonColumn&gt;
            &lt;/UIRow&gt;
        &lt;/UIContainer&gt;
    &lt;/Body&gt;</pre>

<p>The code behind page is relatively simple - the complexity is in the boilerplate code in parent classes. It loads the record specific Controller service.</p>

<pre lang="c#">
// CEC.Weather/Components/Forms/WeatherForecastViewerForm.razor.cs
public partial class WeatherViewer : RecordComponentBase&lt;DbWeatherForecast&gt;
{
    public partial class WeatherViewer : RecordComponentBase&lt;DbWeatherForecast, WeatherForecastDbContext&gt;
    {
        [Inject]
        private WeatherForecastControllerService ControllerService { get; set; }

        public override string PageTitle =&gt; $&quot;Weather Forecast Viewer {this.Service?.Record?.Date.AsShortDate() ?? string.Empty}&quot;.Trim();

        protected async override Task OnInitializedAsync()
        {
            this.Service = this.ControllerService;
            await base.OnInitializedAsync();
        }

        //  example code to show jumping records with querystring changes
        protected void NextRecord(int increment) 
        {
            var rec = (this._ID + increment) == 0 ? 1 : this._ID + increment;
            rec = rec &gt; this.Service.BaseRecordCount ? this.Service.BaseRecordCount : rec;
            this.NavManager.NavigateTo($&quot;/WeatherForecast/View?id={rec}&quot;);
        }
    }
}</pre>

<h3>UI Controls</h3>

<p>The application uses UI Controls to separate HTML and CSS markup from Views and Forms. Bootstrap is used as the UI Framework.</p>

<h5>UIBase</h5>

<p>All library UI Controls inherit from <code>UIBase</code>. This implements <code>IComponent</code>, we don&#39;t use <code>ComponentBase</code> because we don&#39;t need it&#39;s complexity. The complete class is too long to show - you can view it <a href="https://github.com/ShaunCurtis/CEC.Blazor/blob/master/CEC.Blazor/Components/UIControls/UI/UIBase.cs">here</a>.</p>

<p>It builds an HTML DIV block that you can turn on or off.</p>

<p><code>IComponent</code> looks like this.</p>

<pre lang="c#">
public interface IComponent
{
    /// Called by the builder to attach it to a render tree
    void Attach(RenderHandle renderHandle);
    /// Called by the render tree whenever the component parameters are changed
    Task SetParametersAsync(ParameterView parameters);
}
</pre>

<p><code>Attach</code> is called whenever a render tree is built by the RenderTreeBuilder and attaches the component to the render tree.  We assign *renderHandle* to a class property *_renderHhandle*.  The *RenderHandle* class gives us access to the RenderQueue on the RenderTree through <code>RenderHandle.Render(RenderFragment)</code>. </p>

<p><code>RenderFragment</code> is a delegate which is run by the RenderQueue executer.  We build the RenderFragment property <code>_componentRenderFragment</code> in the class initialisation method.  You can see it below. It sets the *_RenderEventQueued* property to false as it's now being run, and calls <code>BuildRenderTree</code> which builds the components markup code.</p>

<p><code>StateHasChanged</code> is our method for triggering a UI update.  It sets <code>_RenderEventQueued</code> property to true and loads <code>_componentRenderFragment</code> into the Render Tree RenderQueue.</p>

<pre lang="c#">
// Code blocks from CEC.Blazor/Components/UIControls/UIBase.cs

// RenderHandle assigned in Attack
private RenderHandle _renderHandle;

//  Class initialisation - we build the RenderFragement _componentRenderFragment
public UIBase() => _componentRenderFragment = builder =>
{
    this._RenderEventQueued = false;
    BuildRenderTree(builder);
};

//  IComponent Interface Method - called by the RenderTree Builder when it attaches the component to a Render Tree
public void Attach(RenderHandle renderHandle) => _renderHandle = renderHandle;

// Method to kick off a re-render of the component
public void StateHasChanged()
{
    // Check if we already have a render queued - if so then it will handle the changes
    if (!this._RenderEventQueued)
    {
        // Flag so we know we have a render queued
        this._RenderEventQueued = true;
        // Load the Render Fragment into the Render Queue
        _renderHandle.Render(_componentRenderFragment);
    }
}
</pre>

<p>Whenever the component's Parameters are changed in the Render Tree, <code>SetParametersAsync</code> is called.  In <code>UIBase</code> we have a simple rendered component so we update the component parameters by calling <code>SetParameterProperties(this)</code> and then re-render the component by calling <code>StateHasChanged</code></p>

<pre lang="c#">
    public virtual Task SetParametersAsync(ParameterView parameters)
{
    parameters.SetParameterProperties(this);
    StateHasChanged();
    return Task.CompletedTask;
}
</pre>


<h5>UIBootstrapBase</h5>

<p><code>UIBootstrapBase</code> adds extra functionality for Bootstrap components. Formatting options such a component colour and sizing are represented as Enums, and Css fragments built based on the selected Enum.</p>

<pre lang="c#">
// CEC.Blazor/Components/UIControls/UIBootstrapBase.cs
public class UIBootstrapBase : UIBase
{
    protected virtual string CssName { get; set; } = string.Empty;

    /// Bootstrap Colour for the Component
    [Parameter]
    public Bootstrap.ColourCode ColourCode { get; set; } = Bootstrap.ColourCode.info;

    /// Bootstrap Size for the Component
    [Parameter]
    public Bootstrap.SizeCode SizeCode { get; set; } = Bootstrap.SizeCode.normal;

    /// Property to set the HTML value if appropriate
    [Parameter]
    public string Value { get; set; } = &quot;&quot;;

    /// Property to get the Colour CSS
    protected virtual string ColourCssFragment =&gt; GetCssFragment&lt;Bootstrap.ColourCode&gt;(this.ColourCode);

    /// Property to get the Size CSS
    protected virtual string SizeCssFragment =&gt; GetCssFragment&lt;Bootstrap.SizeCode&gt;(this.SizeCode);

    /// CSS override
    protected override string _Css =&gt; this.CleanUpCss($&quot;{this.CssName} {this.SizeCssFragment} {this.ColourCssFragment} {this.AddOnCss}&quot;);

    /// Method to format as Bootstrap CSS Fragment
    protected string GetCssFragment&lt;T&gt;(T code) =&gt; $&quot;{this.CssName}-{Enum.GetName(typeof(T), code).Replace(&lt;span class=&quot;pl-pds&quot;&gt;&quot;_&quot;, &quot;-&quot;)}&quot;&lt;/span&gt;;
}
</pre>

<h3>Some Examples</h3>

<h5>UIButton</h5>

<p>This is a standard Bootstrap Button.</p>

<ol>
	<li><code>ButtonType</code> and <code>ClickEvent</code> are specific to buttons.</li>
	<li><code>CssName</code> and <code>_Tag</code> are hardwired.</li>
	<li><code>ButtonClick</code> handles the button click event.</li>
	<li><code>BuildRenderTree</code> builds the markup and wires the JSInterop <code>onclick</code> event.</li>
	<li><code>Show</code> controls whether the button gets rendered.</li>
</ol>

<pre lang="c#">
// CEC.Blazor/Components/UIControls/UIButton.cs
public class UIButton : UIBootstrapBase
{
    /// Property setting the button HTML attribute Type
    [Parameter]
    public string ButtonType { get; set; } = &quot;button&quot;;

    /// Override the CssName
    protected override string CssName =&gt; &quot;btn&quot;;

    /// Override the Tag
    protected override string _Tag =&gt; &quot;button&quot;;

    /// Callback for a button click event
    [Parameter]
    public EventCallback&lt;MouseEventArgs&gt; ClickEvent { get; set; }

    protected override void BuildRenderTree(RenderTreeBuilder builder)
    {
        if (this.Show)
        {
            builder.OpenElement(0, this._Tag);
            builder.AddAttribute(1, &quot;type&quot;, this.ButtonType);
            builder.AddAttribute(2, &quot;class&quot;, this._Css);
            builder.AddAttribute(3, &quot;onclick&quot;, EventCallback.Factory.Create&lt;MouseEventArgs&gt;(this, this.ButtonClick));
            builder.AddContent(4, ChildContent);
            builder.CloseElement();
        }
    }

    /// Event handler for button click
    protected void ButtonClick(MouseEventArgs e) =&gt; this.ClickEvent.InvokeAsync(e);
}</pre>

<p>Here&#39;s some code showing the control in use.</p>

<pre lang="c#">
// CEC.Weather/Components/Forms/WeatherViewer.razor
&lt;UIButtonColumn Columns=&quot;6&quot;&gt;
    &lt;UIButton Show=&quot;!this.IsModal&quot; ColourCode=&quot;Bootstrap.ColourCode.nav&quot; ClickEvent=&quot;(e =&gt; this.NavigateTo(PageExitType.ExitToList))&quot;&gt;
        Exit To List
    &lt;/UIButton&gt;
    &lt;UIButton Show=&quot;!this.IsModal&quot; ColourCode=&quot;Bootstrap.ColourCode.nav&quot; ClickEvent=&quot;(e =&gt; this.NavigateTo(PageExitType.ExitToLast))&quot;&gt;
        Exit
    &lt;/UIButton&gt;
    &lt;UIButton Show=&quot;this.IsModal&quot; ColourCode=&quot;Bootstrap.ColourCode.nav&quot; ClickEvent=&quot;(e =&gt; this.ModalExit())&quot;&gt;
        Exit
    &lt;/UIButton&gt;
&lt;/UIButtonColumn&gt;</pre>

<h5>UIAlert</h5>

<p>This is a standard Bootstrap Alert.</p>

<ol>
	<li><code>Alert</code> is a class to encapsulate an Alert.</li>
	<li><code>ColourCssFragement</code>, <code>Show</code> and <code>_Content</code> are wired into the Alert object instance.</li>
</ol>

<pre lang="c#">
// CEC.Blazor/Components/UIControls/UI/UIAlert.cs
public class UIAlert : UIBootstrapBase
{
    /// Alert to display
    [Parameter]
    public Alert Alert { get; set; } = new Alert();

    /// Set the CssName
    protected override string CssName =&gt; &quot;alert&quot;;

    /// Property to override the colour CSS
    protected override string ColourCssFragment =&gt; this.Alert != null ? GetCssFragment&lt;Bootstrap.ColourCode&gt;(this.Alert.ColourCode) : GetCssFragment&lt;Bootstrap.ColourCode&gt;(this.ColourCode);

    /// Boolean Show override
    protected override bool _Show =&gt; this.Alert?.IsAlert ?? false;

    /// Override the content with the alert message
    protected override string _Content =&gt; this.Alert?.Message ?? string.Empty;
}</pre>

<p>Here&#39;s some code showing the control in use.</p>

<pre lang="c#">
// CEC.Weather/Components/Forms/WeatherEditor.razor
&lt;UIContainer&gt;
    &lt;UIRow&gt;
        &lt;UIColumn Columns=&quot;7&quot;&gt;
            &lt;UIAlert Alert=&quot;this.AlertMessage&quot; SizeCode=&quot;Bootstrap.SizeCode.sm&quot;&gt;&lt;/UIAlert&gt;
        &lt;/UIColumn&gt;
        &lt;UIButtonColumn Columns=&quot;5&quot;&gt;
             .........
        &lt;/UIButtonColumn&gt;
    &lt;/UIRow&gt;
&lt;/UIContainer&gt;</pre>

<h5>UIErrorHandler</h5>

<p>This component deals with loading operations and errors. It&#39;s inherits directly from UIBase. It has three states:</p>

<ol>
	<li>Loading when it displays the loading message and the spinner.</li>
	<li>Error when it displays an error message.</li>
	<li>Loaded when it displays the Child Content.</li>
</ol>

<p>The state is controlled by the two boolean Parameters. Content is only accessed and rendered when the control knows there&#39;s data to render i.e. when <code>IsError</code> and <code>IsLoading</code> are both false. This saves implementing a lot of error checking in the child content.</p>

<pre lang="c#">
// CEC.Blazor/Components/UIControls/UI/UIErrorHandler.cs
public class UIErrorHandler : UIBase
{
    /// Boolean Property that determines if the child content or an error message is diplayed
    [Parameter]
    public bool IsError { get; set; } = false;

    /// Boolean Property that determines if the child content or an loading message is diplayed
    [Parameter]
    public bool IsLoading { get; set; } = true;

    /// CSS Override
    protected override string _BaseCss =&gt; this.IsLoading? &quot;text-center p-3&quot;: &quot;label label-error m-2&quot;;

    /// Customer error message to display
    [Parameter]
    public string ErrorMessage { get; set; } = &quot;An error has occured loading the content&quot;;

        
    protected override void BuildRenderTree(RenderTreeBuilder builder)
    {
        this.ClearDuplicateAttributes();
        if (IsLoading)
        {
            builder.OpenElement(1, &quot;div&quot;);
            builder.AddAttribute(2, &quot;class&quot;, this._Css);
            builder.OpenElement(3, &quot;button&quot;);
            builder.AddAttribute(4, &quot;class&quot;, &quot;btn btn-primary&quot;);
            builder.AddAttribute(5, &quot;type&quot;, &quot;button&quot;);
            builder.AddAttribute(6, &quot;disabled&quot;, &quot;disabled&quot;);
            builder.OpenElement(7, &quot;span&quot;);
            builder.AddAttribute(8, &quot;class&quot;, &quot;spinner-border spinner-border-sm pr-2&quot;);
            builder.AddAttribute(9, &quot;role&quot;, &quot;status&quot;);
            builder.AddAttribute(10, &quot;aria-hidden&quot;, &quot;true&quot;);
            builder.CloseElement();
            builder.AddContent(11, &quot;  Loading...&quot;);
            builder.CloseElement();
            builder.CloseElement();
        }
        else if (IsError)
        {
            builder.OpenElement(1, &quot;div&quot;);
            builder.OpenElement(2, &quot;span&quot;);
            builder.AddAttribute(3, &quot;class&quot;, this._Css);
            builder.AddContent(4, ErrorMessage);
            builder.CloseElement();
            builder.CloseElement();
        }
        else builder.AddContent(1, ChildContent);
    }
}</pre>

<p>Here&#39;s some code showing the control in use.</p>

<pre lang="c#">
// CEC.Weather/Components/Forms/WeatherViewer.razor
&lt;UICard&gt;
    &lt;Header&gt;
        @this.PageTitle
    &lt;/Header&gt;
    &lt;Body&gt;
        &lt;UIErrorHandler IsError=&quot;this.IsError&quot; IsLoading=&quot;this.IsDataLoading&quot; ErrorMessage=&quot;@this.RecordErrorMessage&quot;&gt;
            &lt;UIContainer&gt;
            ..........
            &lt;/UIContainer&gt;
        &lt;/UIErrorHandler&gt;
        .......
    &lt;/Body&gt;</pre>

<h5>UIContainer/UIRow/UIColumn</h5>

<p>Thess creates a BootStrap Container, Row and Column. They build out DIVs with the correct Css.</p>

<pre lang="c#">
// CEC.Blazor/Components/UIControls/UIBootstrapContainer/UIContainer.cs
    public class UIContainer : UIBase
    {
        // Overrides the _BaseCss property to force the css_
        protected override string _BaseCss =&gt; &quot;container-fluid&quot;;
    }</pre>

<pre lang="c#">
// CEC.Blazor/Components/UIControls/UIBootstrapContainer/UIRow.cs
    public class UIRow : UIBase
    {
        protected override string _BaseCss =&gt; &quot;row&quot;;
    }</pre>

<pre lang="c#">
// CEC.Blazor/Components/UIControls/UIBootstrapContainer/UIColumn.cs
public class UIColumn : UIBase
{
    [Parameter]
    public int Columns { get; set; } = 1;

    protected override string _BaseCss =&gt; $&quot;col-{Columns}&quot;;
}</pre>

<pre lang="c#">
// CEC.Blazor/Components/UIControls/UIBootstrapContainer/UILabelColumn.cs
public class UILabelColumn : UIColumn
{
    protected override string _BaseCss =&gt; $&quot;col-{Columns} col-form-label&quot;;
}</pre>

<p>Here&#39;s some code showing the controls in use.</p>

<pre lang="c#">
// CEC.Weather/Components/Forms/WeatherViewer.razor
&lt;UIContainer&gt;
    &lt;UIRow&gt;
        &lt;UILabelColumn Columns=&quot;2&quot;&gt;
            Date
        &lt;/UILabelColumn&gt;
        ............
    &lt;/UIRow&gt;
..........
&lt;/UIContainer&gt;</pre>

<h3>Wrap Up</h3>

<p>This article provides an overview on building UI Controls with components, and examines some example components in more detail. You can see all the library UIControls in the GitHub Repository - <a href="https://github.com/ShaunCurtis/CEC.Blazor/tree/master/CEC.Blazor/Components/UIControls">CEC.Blazor/Components/UIControls</a></p>

<p>Some key points to note:</p>

<ol>
	<li>UI Controls lets you abstract the markup from your components.</li>
	<li>UI Controls gives you project control over the HTML and Css markup.</li>
	<li>Your main View and Form components are much cleaner and easier to view.</li>
	<li>You can use as little or as much abstraction as you wish.</li>
</ol>
